@startuml IPC
    ' An `IChannel` is an abstraction over a collection of commands
    ' You can `call` several commands on a channel, each taking at
    ' most one single argument. A `call` always returns a promise
    ' with at most one single return value.
    interface IChannel{
        + Promise<T> call<T>(string command, any arg?, CancellationToken cancellationToken)
        + Event<T> listen<T>(string event, any arg?)
    }
    ' An `IChannelClient` has access to a collection of channels. You are able to get those channels, given their channel name.
    interface IChannelClient {
        + T getChannel<T extends IChannel>(string channelName)
    }
    ' counterpart：某人的counter part是指与他有相似职位的人；某物的counter part是指与它有相似功能的物
    ' An `IServerChannel` is the counter part to `IChannel`,on the server-side.
    interface IServerChannel<TContext=string>{
        + Promise<T> call<T>(TContext ctx, string command, any arg?, CancellationToken cancellationToken?)
        + Event<T> listen<T>(TContext ctx, string event, any arg?)
    }
    ' An `IChannelServer` hosts a collection of channels. You are able to register channels onto it, provided a channel name.
    interface IChannelServer<TContext = string> {
        + void registerChannel(string channelName, IServerChannel<TContext> channel)
    }
    interface IMessagePassingProtocol {
        + void send(VSBuffer buffer)
        + Promise<void> drain()?
        + Event<VSBuffer> onMessage
    }
    interface IClientRouter<TContext=string>{
        + Promise<Client<TContext>> routeCall(IConnectionHub<TContext> hub, string command, any arg?, CancellationToken cancellationToken?)
        + Promise<CLient<TContext>> routeEvent(IConnectionHub<TContext> hub, string event, any arg?)
    }
    ' Similar to the `IChannelClient`, you can get channels from this
    ' collection of channels. The difference being that in the
    ' `IRoutingChannelClient`, there are multiple clients providing
    ' the same channel. You'll need to pass in an `IClientRouter` in
    ' order to pick the right one
    interface IRouteingChannelClient<TContext=string> {
        + T getChannel<T extends IChannel>(string channelName, IClientRouter<TContext> router?)
    }
    interface IRoutingChannelClient<TContext> {}
    interface IConnectionHub<TContext> {
        + readonly Connection<TContext>[] _connections
        + readonly Event<Connection<TContext>> onDidAddConnection
        + readonly Event<Connection<TContext>> onDidRemoveConnection
    }
    interface IDisposable {}
    IChannelServer <|.. IPCServer
    IRoutingChannelClient <|.. IPCServer
    IConnectionHub <|.. IPCServer
    IDisposable <|.. IPCServer
    IServerChannel <.. IPCServer
    Connection <.. IPCServer
    Emitter <--* IPCServer
    IClientRouter <.. IPCServer
    ' An `IPCServer` is both a channel server and a routing channel client
    ' As the owner of a protocol, you should extend both this
    ' and the `IPCClient` classes to get IPC implementations for your protocol.
    class IPCServer<TContext = string> {
        - Map<string, IServerChannel<IContext>>
        - Set<Connection<IContext>> _connections
        - readonly Emitter<Connection<TContext>> _onDidAddConnection
        + readonly Event<Connection<TContext>> onDidRemoveConnection
        - readonly Emitter<Connection<TContext>> _onDidRemoveConnection
        + readonly Event<Connection<TContext>> onDidRemoveConnection
        + IPCServer(Event<ClientConnectionEvent> onDidClientConnect)
        + T getChannel<T extends IChannel>(string channelName, IClientRouter<TContext> route)
        + T getChannel<T extends IChannel>(string channelName, function clientFilter)
        + T getChannel<T extends IChannel>(string channelName, IClientRouter<TContext> routeOrClientFilter)
        - any getMulticastEvent(string channelName, any clientFilter)
        + void registerChannel(string channelName, IServerChannel<TContext> channel)
        + void dispose()
    }
    interface Client<TContext> {
        + readonly TContext ctx
    }
    ' An `IClientRouter` is responsible for routing calls to specific channels
    ' in scenarios in which there are multiple possible channels (each from a separate client) to pick from.
    interface IClientRouter<TContext=string> {
        + Promise<Client<TContext>> routeCall(IConnectionHub<TContext> hub, string command, any arg?, CancellationToken cancellationToken)
        + Promise<Client<TContext>> routeEvent(IConnectionHub<TContext> hub, string event, any arg?)
    }
    IChannelClient <|.. IPCClient
    IChannelServer <|.. IPCClient
    IDisposable <|.. IPCClient
    ' An `IPCClient` is both a channel client and a channel server.
    ' As the owner of a protocol, you should extend both this
    ' and the `IPCClient` classes to get IPC implementations
    ' for your protocol.
    class IPCClient<TContext=string> {
        - ChannelClient channelClient
        - ChannelServer<TContext> channelServer
        IPCClient(IMessagePassingProtocol protocol, TContext ctx, IIPCLogger|null ipcLogger)
        + T getChannel<T extends IChannel>(string channelName)
        + void registerChannel(string channelName, IServerChannel<TContext> channel)
        + void dispose()
    }
    interface IReader {
        + VSBuffer read(number bytes)
    }
    interface IWrite {
        + void write(VSBuffer buffer)
    }
    IReader <|.. BufferReader
    class BufferReader {
        - muber pos
        BufferReader(VSBuffer buffer)
        + VSBuffer read(number bytes)
    }
    IWrite <|.. BufferWrite
    class BufferWrite {
        - VSBuffer[] buffers
        + VSBuffer buffer()
        + void write(VSBuffer buffer)
    }
    IChannelServer <|.. ChannelServer
    IDisposable <|.. ChannelServer
    class ChannelServer<TContext=string> {
        - Map<string, IServerChannel<TContext>> channels
        - Map<number, IDisposable> activeRequests
        - IDisposable|null protocolListener
        - Map<string, PendingRequest[]> pendingRequests
        ChannelServer(IMessagePassingProtocol protocol, TContext ctx, IIPCLogger|null logger, number timeoutDelay)
        + void registerChannel(string channelName, IServerChannel<TContext> channel)
        - void sendResponse(IRawResponse response)
        - number send(any header, any body)
        - number sendBuffer(VSBuffer message)
        - void onRawMessage(VSBuffer message)
        - void onPromise(IRawPromiseRequest request)
        - void onEventListen(IRawEventListenRequest request)
        - void disposeActiveRequest(IRawRequest request)
        - void collectPendingRequest(IRawPromiseRequest|IRawEventListenRequest request)
        - void flushPendingRequests(string channelName)
        + void dispose()
    }
    interface IIPCLogger {
        + void logIncoming(number msgLength, number requestId, RequestInitiator initiator, string str, any data?)
        + void logOutgoing(number msgLength, number requestId, RequestInitiator initiator, string str, any data?)
    }
    IChannelClient <|.. ChannelClient
    IDisposable <|.. ChannelClient
    class ChannelClient {
        - State state
        - Set<IDisposable> activeRequests
        - Map<number, IHandler> handlers
        - number lastRequestId
        - IDisposable|null protocolListener
        - IIPCLogger|null logger
        - readonly Emitter<void> _onDidInitialize
        ChannelClient(IMessagePassingProtocol protocol, IIPCLogger|null logger)
        + T getChannel<T extends IChannel>(string channelName)
        - Promise<any> requestPromise(string channelName, string name, any arg?, CancellationToken cancellationToken)
        - Event<any> requestEvent(string channelName, string name, any arg?)
        - void sendRequest(IRawRequest request)
        - number send(any header, any body)
        - number sendBuffer(VSBuffer message)
        - void onBuffer(VSBuffer message)
        - void onResponse(IRawResponse response)
        - Promise<void> whenInitialized()
        + void dispose()
    }
    interface ClientConnectionEvent {
        + IMessagePassingProtocol protocol
        + Event<void> onDidClientDisconnect
    }
    Client <|-- Connection
    interface Connection<TContext> {
        + readonly ChannelServer<TContext> channelServer
        + readonly ChannelClient channelClient
    }

@enduml